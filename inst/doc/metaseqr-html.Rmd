<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{RNA-Seq data analysis and meta-analysis with metaseqr}
-->

RNA-Seq data analysis and meta-analysis with metaseqr
==================================================

During the past few years, a lot of R/Bioconductor packages have been developped for the analysis of RNA-Seq data, introducing several
approaches. For example, packages using the negative binomial distribution to model the null hypotheses (_DESeq_, _edgeR_, _NBPSeq_)
or packages using Bayesian statistics (_baySeq_, _EBSeq_). In addition, packages specialized to RNA-Seq data normalization have 
also been developed (_EDASeq_). The package _metaseqr_ tries to provide an interface to several algorithms, similar to the recent 
_TCC_ package. However, it is much simpler to use than _TCC_, incoporates more algorithms for normalization and statistical 
analysis and builds a full report with several interactive and non-interactive diagnostic plots so that the users can easily explore 
the results and have whatever they need for this part of their research in one place. The metaseqr report is one of its most strong points
as it provides an automatically generated summary, based on the pipeline inputs and the results, which can be used directly as a draft
in methods paragraph in scientific publications. It also provides a lot of diagnostic figures and each figure is accompanied by a small
explanatory text, and a list of references accroding to the algorithms used in the pipeline, which can also be used in a scientific
article. All the report components are grouped in a comprehensive way, with a table of contents. Most importantly, metaseqr provides an interface 
for RNA-Seq data meta-analysis by providing the ability to use different algorithms for the statistical testing part and combining the 
p-values using popular published methods (e.g. Fisher's method, Whitlock's method) and two package-specific methods (intersection, union 
of statistically significant results). In the future, more algorithms will be incorporated in the package, with more diagnostic plots and more
examples. This initial vignette contains just this introductory text and reference to some examples in the package documentation, which 
we believe that at this point contains sufficient explanation to run the metaseqr pipeline.

## 1 Getting started

Detailed instructions on how to run the metaseqr pipeline can be found under the main documentation of the metaseqr package:

```{r}
library(metaseqr)
```

```{r eval=FALSE}
library(metaseqr)
help(metaseqr) # or
help(metaseqr.main)
```

Briefly, to run metaseqr you need:

- A text tab delimited file in a spreadsheet like format containing at least unique gene identifiers (corresponding to one of metaseqr's
supported formats, for the time being Ensembl
- A list of statistical contrasts for which you wish to check differential expression
- An internet connection so that the interactive parts of the report can be properly rendered, as the report template points to external
Content Delivery Networks (CDNs) distributing the appropriate JavaScript

Everything else (e.g. genomic regions annotation etc.) can be handled by the metaseqr pipeline. Some example data are included in the
package. See the related help pages:

```{r eval=FALSE}
help(hg18.exon.data)
help(mm9.gene.data)
```

## 2 Running the metaseqr pipeline

Running a metaseqr pipeline instance is quite straightforward. Again, see the examples in the main help page. An example and the command
window output follow:

```{r echo=TRUE, eval=TRUE}
data("mm9.gene.data",package="metaseqr")
```

```{r echo=TRUE, eval=TRUE}
head(mm9.gene.counts)
```

```{r echo=TRUE, eval=TRUE}
sample.list.mm9
```

```{r echo=TRUE, eval=TRUE}
libsize.list.mm9
```

Now, running

```{r echo=TRUE, eval=FALSE, tidy=FALSE}
result <- metaseqr(
	counts=mm9.gene.counts,
	sample.list=sample.list.mm9,
	contrast=c("e15.5_vs_P0.5","P0.5_vs_P60"),
	libsize.list=libsize.list.mm9,
	annotation="fixed",
	org="mm9",
	count.type="gene",
	normalization="edger",
	statistics="edger",
	pcut=0.05,
	fig.format=c("png","pdf"),
	export.what=c("annotation","p.value","meta.p.value","adj.meta.p.value","fold.change"),
	export.scale=c("natural","log2"),
	export.values="normalized",
	export.stats=c("mean","sd","cv"),
	export.where="~/metaseqr_test",
	restrict.cores=0.8,
	gene.filters=list(
		length=list(
			length=500
		),
		avg.reads=list(
			average.per.bp=100,
			quantile=0.25
		),
		expression=list(
			median=TRUE,
			mean=FALSE,
			quantile=NA,
			known=NA,
			custom=NA
		),
		biotype=get.defaults("biotype.filter","mm9")
	),
	out.list=TRUE
)
```

will result in the following output in the command window:

```{r echo=FALSE, eval=TRUE, message=FALSE}
result <- metaseqr(
	counts=mm9.gene.counts,
	sample.list=sample.list.mm9,
	contrast=c("e15.5_vs_P0.5","P0.5_vs_P60","e15.5_vs_P0.5_vs_P60"),
	libsize.list=libsize.list.mm9,
	annotation="fixed",
	org="mm9",
	count.type="gene",
	normalization="edger",
	statistics="edger",
	pcut=0.05,
	fig.format=c("png","pdf"),
	export.what=c("annotation","p.value","meta.p.value","adj.meta.p.value","fold.change"),
	export.scale=c("natural","log2"),
	export.values="normalized",
	export.stats=c("mean","sd","cv"),
	export.where="~/metaseqr_test",
	restrict.cores=0.8,
	gene.filters=list(
		length=list(
			length=500
		),
		avg.reads=list(
			average.per.bp=100,
			quantile=0.25
		),
		expression=list(
			median=TRUE,
			mean=FALSE,
			quantile=NA,
			known=NA,
			custom=NA
		),
		biotype=get.defaults("biotype.filter","mm9")
	),
	out.list=TRUE
)
```

To get a glimpse on the results, running:

```{r echo=TRUE, eval=FALSE}
head(result$data[["e15.5_vs_P0.5"]])
```

will produce

```{r echo=FALSE, eval=TRUE}
head(result$data[["e15.5_vs_P0.5"]])
```

Check the HTML report file created at "~/metaseqr_test".

Now, the same example but with more than one statistical selection algorithms and a different normalization:

```{r eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE}
library(metaseqr)
data("mm9.gene.data",package="metaseqr")
result <- metaseqr(
	counts=mm9.gene.counts,
	sample.list=sample.list.mm9,
	contrast=c("e15.5_vs_P0.5","P0.5_vs_P60","e15.5_vs_P0.5_vs_P60"),
	libsize.list=libsize.list.mm9,
	annotation="fixed",
	org="mm9",
	count.type="gene",
	normalization="edaseq",
	statistics=c("deseq","edger"),
	meta.p="fisher",
	pcut=0.05,
	fig.format=c("png","pdf"),
	export.what=c("annotation","p.value","meta.p.value","adj.meta.p.value","fold.change"),
	export.scale=c("natural","log2"),
	export.values="normalized",
	export.stats=c("mean","sd","cv"),
	export.where="~/metaseqr_test_2",
	restrict.cores=0.8,
	gene.filters=list(
		length=list(
			length=500
		),
		avg.reads=list(
			average.per.bp=100,
			quantile=0.25
		),
		expression=list(
			median=TRUE,
			mean=FALSE,
			quantile=NA,
			known=NA,
			custom=NA
		),
		biotype=get.defaults("biotype.filter","mm9")
	),
	out.list=TRUE
)
```

An additional example with human exon data (if you have a multiple core system, be very careful on how you are using the restrict.cores
option and generally how many cores you are using with scripts purely written in R. The analysis with exon read data can very easily
cause memory problems, so unless you have more than 64Gb of RAM available, consider setting restrict.cores to something like 0.2):

```{r eval=FALSE, tidy=FALSE}
# A full example pipeline with exon counts
data("hg18.exon.data",package="metaseqr")
metaseqr(
	counts=hg18.exon.counts,
	sample.list=sample.list.hg19,
	contrast=c("normal_vs_paracancerous","normal_vs_cancerous","normal_vs_paracancerous_vs_cancerous"),
	libsize.list=libsize.list.hg19,
	id.col=4,
	annotation="download",
	org="hg18",
	count.type="exon",
	normalization="edaseq",
	statistics="deseq",
	pcut=0.05,
	qc.plots=c(
		"mds","biodetection","countsbio","saturation","rnacomp",
		"boxplot","gcbias","lengthbias","meandiff","meanvar",
		"deheatmap","volcano","biodist","filtered"
	),
	fig.format=c("png","pdf"),
	export.what=c("annotation","p.value","adj.p.value","fold.change","stats","counts"),
	export.scale=c("natural","log2","log10","vst"),
	export.values=c("raw","normalized"),
	export.stats=c("mean","median","sd","mad","cv","rcv"),
	restrict.cores=0.8,
	gene.filters=list(
		length=list(
			length=500
		),
		avg.reads=list(
			average.per.bp=100,
			quantile=0.25
		),
		expression=list(
			median=TRUE,
			mean=FALSE
		),
		biotype=get.defaults("biotype.filter","hg19")
	)
)
```

## 3 metaseqr components

The metaseqr package includes several functions which are responsible for running each part of the pipeline (data reading and summarization,
filtering, normalization, statistical analysis and meta-analysis and reporting). Although metaseqr is designed to run as a pipeline, where
all the parameters for each individual part can be passed in the main function, several of the individual functions can be run separately
so that the more experienced user can build custom pipelines. All the HTML help pages contain analytical documentation on how to run these
functions, their inputs and outputs and contain basic examples. For example, runnning

```{r eval=FALSE}
help(stat.edgeR)
```

will open the help page of the wrapper function over the edgeR statistical testing algorithm which contains an example of data generation,
processing, up to statistical selection.

Most of the diagnostic plots, work with simple matrices as inputs, so they can be easily used outside the main pipeline, as long as all
the necessary arguments are given. It should be noted that a report can be generated only when running the whole metaseqr pipeline and in
the current version there is no support for generating custom reports.

A very detailed documentation on how to run metaseqr and explanation for all its parameters can be obtained by

```{r eval=FALSE}
help(metaseqr)
```

## 4 R session information

```{r}
sessionInfo()
```
